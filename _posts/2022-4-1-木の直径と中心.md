---
layout: page
title: 重みなし無向木の直径と中心
tags: [競プロ, アルゴリズム, 数学]
---

## Intro

ブログを乗り換えたので初投稿です。

最近いろいろあって木の直径と中心について考える機会があったのでそれをまとめます。

離散数学が扱うグラフ理論という分野に「木」という概念があります。\
グラフ、という概念について説明はしないので必要であれば各自で調べてください。

木についてこの記事で扱う中では以下のような性質があります。

- 木は連結であり、自己ループや閉路を持たない(木の定義)
- その木の頂点数が$$V$$であるとき、木はちょうど$$V-1$$本の辺を持つ
- 任意の木について直径という値(or パス)が存在する
- ある頂点を選んだとき、その頂点から最も離れた頂点が木の直径の端点となる

これらについて、この記事では証明をせずに使っていくこととします。

## Diameter

まず、直径について定義しておく必要がありそうです。\
グラフ理論における直径とは、

> 2点間の距離における最長のものの値

です。\
特に重みなし木について直径とは

> ある頂点から最も離れた頂点に到達するために通った辺の本数。\
> ここで「最も離れた頂点」とはある頂点からその頂点に到達するまでに通った辺の本数が最大となるような頂点のことをいう。これは1つに定まるわけではなく、複数存在する場合がある。

また、直径を直径の値を得られるパスという意味で使う場面もしばしば見かけます。
この記事では**直径をパス、直径の値をそのパスの長さ**として用います。

この直径を重みなし無向グラフ$$\hspace{0.2em}G \hspace{0.2em} = (V, E)$$において求める有名なアルゴリズムにdouble sweepというものがあります。[^1]\
競技プログラミングの文脈でもよく見かけるアルゴリズムですから、馴染みのある人も多いと思います。

直径はこのdouble sweepを用いると以下のようなコードで求めることができます。

```cpp
#include <iostream>
#include <vector>
#include <queue>

void bfs(int start, std::vector<std::vector<int>> &g, int &ep, int &ed) {
    std::vector<int> dist(g.size(), -1);
    dist[start] = 0;
    std::queue<int> q;
    q.push(start);

    while(!q.empty()){
        int now = q.front();
        q.pop();

        for (auto x : g[now]){
            if (dist[x] == -1){
                q.push(x);
                dist[x] = dist[now]+1;

                if (dist[x] > ed){
                    ed = dist[x];
                    ep = x;
                }
            }
        }
    }
}

int main(){
    int v;
    std::cin >> v;

    std::vector<std::vector<int>> g(v);

    for (int i = 0; i < v-1; i++){
        int ai, bi; std::cin >> ai >> bi;
        ai--; bi--;
        g[ai].push_back(bi);
        g[bi].push_back(ai);
    }

    int edge_point = -1, edge_dist = 0;
    bfs(0, g, edge_point, edge_dist);
    std::cerr << edge_point << " " << edge_dist << std::endl;

    int opposite_edge = -1, opposite_dist = 0;
    bfs(edge_point, g, opposite_edge, opposite_dist);

    std::cout << "Diameter's edge : (" << edge_point << ", " << opposite_edge << ")" << std::endl;
    std::cout << "Diameter        : " << opposite_dist << std::endl;
}
```

このプログラムに対して簡単な木を与えてみます。

![](https://firebasestorage.googleapis.com/v0/b/kdatabase-1088a.appspot.com/o/Tree_Center%2FTree_center_diameter_1.png?alt=media&token=54094be0-72a9-4456-a72e-6be0faf28da5)

```
4
1 3
2 3
3 4
```

と入力すると

```
Diameter's edge : (1, 0)
Diameter        : 2
```

の出力を得ます。

入力は1-indexedのグラフですが出力が0-indexedなグラフであることに留意すると、どうやら

> 1 → 3 → 2

というパスを直径として直径の値2を得たようです。\
実際これは正しいです。

また以下の出力も正しい出力です。

```
Diameter's edge : (3, 0)
Diameter        : 2
```

このように一つの木に同じ直径の値を与えるパスが複数存在する場合もあります。\
重みつきグラフで同じことをやりたかったらまあワーシャルフロイド法でも使えばいいんじゃないでしょうか。

もっと複雑な木について見てみます。

適当に木を生成してGraphvizを用いてビジュアライズしてみたものがこちらです。
めちゃくちゃデカいので別のタブで開いて見てください。

![](https://firebasestorage.googleapis.com/v0/b/kdatabase-1088a.appspot.com/o/Tree_Center%2FTree_center_diameter_2.jpeg?alt=media&token=a7707b9e-d535-4da4-b618-fb0be8c3717b)

生データはこちらです。

[生データ(txtファイル)](https://firebasestorage.googleapis.com/v0/b/kdatabase-1088a.appspot.com/o/Tree_Center%2Ftestcase1.txt?alt=media&token=7eb384d3-1d48-42ec-8d7b-85118629c0ce)

これを入力として与えると

```
Diameter's edge : (52, 39)
Diameter        : 19
```

という出力を得ます。

これを用いて先程のビジュアライズ上で直径をマークしてみるとこのようになります。

![](https://firebasestorage.googleapis.com/v0/b/kdatabase-1088a.appspot.com/o/Tree_Center%2FTree_center_diameter_3.jpeg?alt=media&token=dcec49a3-e512-4715-8702-f43cc52ee9c5)

まあなんとなく遠そうな気はしますよね。\
本当ならトポロジカルソートをして見やすくできれば良かったのですが、ちょっと面倒なのでやめました。すいません。

ところで、これが本当に直径かどうかを確かめるにはパスに含まれる頂点の数を調べればよいです。\
ここで一旦直径に含まれる頂点以外を見なかったことにしてみると、ただのパスグラフ[^2]になります。

したがって、直径に含まれる頂点の数を調べ、頂点の数$$-1$$が直径の値と一致していればそれが直径で間違いありません。\
木上のある頂点の組$$\hspace{0.2em}(a, \hspace{0.2em}b)\hspace{0.2em}$$について経路はただ一つに定まるからです。

ということで、任意の重みなし木について直径の値とその端点を求めることが可能になりました。

## Center

新たに1つの関数と2つの用語を定義します。

- $$\mathrm{dist}(x, y) := x, y\hspace{0.2em}$$間の最短距離(ここでは最短パスに含まれる辺の本数)

- 離心数
  - 頂点$$v$$から最も離れた頂点を$$w$$としたとき、$$\mathrm{dist}(v, w)$$を$$v$$の離心数という。またこれを$$\epsilon(v)$$[^3]と書くことがある。

- 木の中心
  - $$\epsilon(v)$$が他の任意の頂点$$w$$について$$\epsilon(v) \le \epsilon(w)$$となるような頂点

ここからはこの木の中心について話を進めていきます。

まず、以下を示します。

> ある木の直径の値を$$\hspace{0.15em}D$$、中心となる頂点の集合を$$\hspace{0.2em}C\hspace{0.15em}$$としたとき$$\hspace{0.2em}C\hspace{0.15em}$$の任意の要素$$\hspace{0.2em}c\hspace{0.15em}$$について$$\hspace{0.2em}\epsilon (c) = \left\lceil \dfrac{D}{2}  \right\rceil$$\
> またそのような$$\hspace{0.2em}C$$の要素$$\hspace{0.2em}c$$は木の直径のうち、直径の片方の端点からちょうど$$\left \lfloor \dfrac{D}{2} \right \rfloor , \left\lceil \dfrac{D}{2} \right\rceil$$だけ離れた頂点である。\
> ただし$$\lceil x \rceil$$は任意の実数$$\hspace{0.2em}x\hspace{0.15em}$$について$$\hspace{0.2em}x\hspace{0.15em}$$以上の最小の整数を、$$\left\lfloor x \right\rfloor$$は$$\hspace{0.2em}x$$以下の最大の整数を表す。

---

直径のパス上に存在する頂点の集合を$$LP$$とします。[^4]\
$$LP$$の各要素のうち直径の片方の端点となる頂点を$$LP_1$$。\
$$LP_1$$から遠い距離にある頂点ほど添字が大きくなるように$$LP_2, LP_3, ..., LP_D$$と順序付けします。

ここで、$$i = 1, 2, ..., D$$について$$\epsilon(LP_i)$$を求めてみます。

このとき$$\epsilon(LP_i)$$は以下のように言い換えられます。

$$
\epsilon(LP_i) = \max(\mathrm{dist}(LP_1, LP_i), \hspace{0.2em}\mathrm{dist}(LP_i, LP_D))
$$

すなわち

$$
\epsilon(LP_i) = \max(i-1, \hspace{0.2em}D-i+1)
$$

です。

ゆえに$$\lbrace E_n \rbrace = \epsilon(LP_n) \ (1 \le n \le D)$$とすると

$$D$$が偶数のとき

$$
\lbrace \hspace{0.05em} E \hspace{0.05em} \rbrace = \left\lbrace D,\hspace{0.2em} D-1,\hspace{0.2em} ...,\hspace{0.2em} \frac{D}{2},\hspace{0.2em} ...,\hspace{0.2em} D-1,\hspace{0.2em} D \right\rbrace
$$

$$D$$が奇数のとき

$$
\lbrace \hspace{0.05em} E \hspace{0.05em} \rbrace = \left\lbrace D, \hspace{0.2em} D-1,\hspace{0.2em} ...,\hspace{0.2em} \left\lceil \frac{D}{2} \right\rceil,\hspace{0.2em} \left\lceil \frac{D}{2} \right\rceil,\hspace{0.2em} ...,\hspace{0.2em} D-1,\hspace{0.2em} D \right\rbrace
$$

となります。

ここで直径に含まれない任意の点$$\hspace{0.15em}x\hspace{0.15em}$$を木の中心、$$h\hspace{0.15em}$$を$$\hspace{0.15em}x\hspace{0.15em}$$から最も近い直径のパス上の頂点したとき、$$\epsilon(x) = \mathrm{dist}(x, h) + \epsilon(h)$$となることは自明です。\
$$h \in LP\hspace{0.2em}$$だから、常に$$\epsilon(h) \le \left\lceil\frac{D}{2}\right\rceil$$です。
また、$$\mathrm{dist}(x, h) > 0$$だから木の中心を直径に含まれない頂点の中から選ぶのは不適当です。[^5]

以上より、ある木について木の中心となる頂点の集合$$\hspace{0.2em}C\hspace{0.15em}$$は直径上に存在する頂点のうち、直径の端点から$$\left\lfloor\frac{D}{2}\right\rfloor, \left\lceil\frac{D}{2}\right\rceil$$だけ離れた頂点からなる有限集合であることがわかります。[^7][^8] $$\hspace{0.5em} \Box$$

---

ところで、直径は一つの木に複数存在する場合があります。
その場合でもどれか一つの直径を選び、中心を定めてしまって良いです。[^6]

よって、以下の木の中心の集合を求めるアルゴリズムを得ます。

1. 任意の頂点$$\hspace{0.15em}x\hspace{0.15em}$$からBFSを行う
2. $$x\hspace{0.15em}$$から最も離れた頂点$$a$$が1つの直径の端点である。$$a$$となりうる頂点が複数存在する場合はそのどれを$$a$$としてもよい
3. $$a$$からBFSを行い、任意の頂点までの距離と、距離が$$i$$であるような頂点を記録しておく
4. $$a$$から最も離れた頂点を$$b$$とする。このとき$$b$$となりうる頂点が複数存在する場合はそのどれを$$b$$としてもよい
5. $$b$$からBFSを行い、任意の頂点までの距離と、距離が$$i$$であるような頂点を記録しておく
6. $$D = \mathrm{dist}(a, b)$$とし、$$a, b$$それぞれから距離が$$\left\lfloor\frac{D}{2}\right\rfloor, \left\lceil\frac{D}{2}\right\rceil$$である頂点をそれぞれ列挙する。
7. 列挙した2つの集合の直積集合が求める集合である。

これをそのまま実装したのが以下のレポジトリにあるコードだったりするのですが、

[ryusuke920/AtCoder-Library/Tree/FindCenter.py](https://github.com/ryusuke920/AtCoder-Library/blob/b9405c17823cbd0cce75026188eca8fc355878ac/Tree/FindCenter.py)

まあ今回はC++で書き直したコードを記載します。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>

std::vector<int> bfs(int start, std::vector<std::vector<int>> &g) {
    std::vector<int> dist(g.size(), -1);
    dist[start] = 0;
    std::queue<int> q;
    q.push(start);

    while(!q.empty()){
        int now = q.front();
        q.pop();

        for (auto x : g[now]){
            if (dist[x] == -1){
                q.push(x);
                dist[x] = dist[now]+1;
            }
        }
    }

    return dist;
}

int main(){
    int v;
    std::cin >> v;
    std::vector<std::vector<int>> g(v);

    for (int i = 0; i < v-1; i++){
        int ai, bi; std::cin >> ai >> bi;
        ai--; bi--;
        g[ai].push_back(bi);
        g[bi].push_back(ai);
    }

    std::vector<int> random_dist = bfs(0, g);
    std::vector<int> dist_A = bfs(std::max_element(random_dist.begin(), random_dist.end())-random_dist.begin(), g);
    std::vector<int> dist_B = bfs(std::max_element(dist_A.begin(), dist_A.end())-dist_A.begin(), g);

    int Diameter = *std::max_element(dist_A.begin(), dist_A.end());
    std::set<int> center_choice;
    for (int i = 0; i < v; i++) {
        if (dist_A[i] == Diameter/2 || dist_A[i] == (Diameter+1)/2){
            center_choice.insert(i);
        }
    }

    std::set<int> center;
    for (int i = 0; i < v; i++) {
        if ((dist_B[i] == Diameter/2 || dist_B[i] == (Diameter+1)/2) && center_choice.count(i) > 0){
            center.insert(i);
        }
    }

    for (auto x : center) std::cout << x << std::endl;
}
```

計算量はBFSで$$\Theta(V+V-1)$$すなわち$$\Theta(V)$$\
その他の関数も全て線形時間で動作するのでプログラム全体の計算量は$$\Theta(V)$$です。

C++であれば$$V < 10^4$$の制約で$$10 \mathrm{[ms]}$$、Pythonでも$$60 \mathrm{[ms]}$$ほどで動作します。\
おそらく$$10^5, 10^6$$くらいまでは他のアルゴリズムと組み合わせても問題なく動作すると思います。(まあGithubリンク先のPythonコードは実行時間とか空間とかそれ以外の原因で$$V < 10^4$$でしか動作が保証されないのですが。)[^9]

## 競技プログラミングでの文脈

競技プログラミングで木の直径は問われているのですが、木の中心が問われることはそこまでありません。\
確かに、木について名前の着いた重要なものといえば直径が真っ先に頭に浮かぶと思うので変な話ではないです。

例えば以下のような問題を考えることができます。

---

ある国に$$1, 2, ..., N$$の$$N$$個の街と$$1, 2, ..., M$$の$$M$$本の道があります。
$$i$$番目の道は街$$a_i, b_i$$を相互につなぎます。

ここである街から他のある街へ0本以上の何本かの道を通って到達できるとき、その2つの街は同じ州に属すると言います。

大統領のYourein君はすべての州に以下の要件を満たすような州都を設置しようとしています。

- ある州のある街から同じ州に属する任意の街への距離のうち最大のものをその街の不便さという。
- 街$$x$$の不便さを$$c(x)$$と置くと、同じ州に属する任意の街$$y$$について$$c(x) \le c(y)$$であるときその街は州都として適している。
- 州都となるに適する街が2つ以上ある場合は街の番号が小さい方を州都とする。

州都となる街それぞれについて不便さを求め、その総和を答えてください。

**制約**

- $$1 \le N \le 10^5$$　
- $$0 \le M \le N-1$$　 
- 同じ州に属する街$$(a, b)$$について$$a$$から$$b$$への経路は常にただ一つに定まる。
- $$\forall i, 1 \le a_i, b_i \le N \ (1 \le i \le N)$$　
- $$\forall i, a_i \neq b_i \ (1 \le i \le N)$$　


---

今適当に作ったので既出だったらすいません。

まず制約からこれは全体でみると連結ではないかもしれないが、各連結成分が木になっているグラフということがわかります。
また、州都の条件は州(連結成分)内で離心数が最も小さい頂点であることです。
したがって、与えられたグラフを連結成分に分解し、連結成分ごとに木の中心を求めることでこの問題を解くことができます。

連結成分分解をちょっとめんどくさがってUnionFindライブラリをペタリとすることにすると連結成分を得るまでに$$\Theta((N+M)\alpha(N))$$[^10]だけかかります。

ここから各連結成分について中心を求めるわけですが、連結成分一つに対して中心を得るためにかかる計算量は$$\Theta(N)$$なので、結局この問題は$$\Theta((N+M)\alpha(N))$$で解けるということになります。[^11]


[^1]: [double sweepに基づくP2Pネットワークの経路長短縮](https://www.rbanno.net/data/paper/202003_IEICE_NS_Kaneko.pdf) 付録参照。多分これではなくしっかりとdouble sweepに言及した論文は存在します。

[^2]: あるグラフの頂点の集合を$$v_1, v_2, v_3, ..., v_n$$と順序付けしたときに辺の集合が$$\lbrace v_i, v_{i+1} \rbrace \ (i = 1, 2, 3, ..., n-1)$$となるグラフのことをパスグラフと言います。

[^3]: 離心数は英語でeccentricityと言います。

[^4]: Longest pathの意を込めています。

[^5]: 木の中心であるならば$$\epsilon(x)$$が$$\lbrace E \rbrace$$の任意の要素よりも小さくなるはずなので

[^6]: 複数ある直径は必ずどこかで交わるはずです。木において複数の直径が連結でないことは絶対にありません。もちろん一般のグラフではありえますが。

[^7]: 結局証明の中では$$D$$を2で割った切り捨てと切り上げの頂点において$$\epsilon(x)$$の値が最小ということを示していないのですが、これは$$\epsilon\left(\left\lfloor\frac{D}{2}\right\rfloor\right)$$と$$\epsilon\left(\left\lceil\frac{D}{2}\right\rceil\right)$$から自明であるとしています。

[^8]: 特に$$D\hspace{0.15em}$$が偶数のとき$$\left\lfloor\frac{D}{2}\right\rfloor = \left\lceil\frac{D}{2}\right\rceil$$です。

[^9]: BFS関数内のdist配列の初期値が10000なので、ある頂点$$(x, y)$$の組が存在し$$\mathrm{dist}(x, y) \ge 10000$$が達成されるようなグラフが入力されたときに落ちます。

[^10]: $$\alpha(x)$$はアッカーマン関数の逆関数です。

[^11]: なかなか定数倍が重いような気もするんですが。